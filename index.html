<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lofi‑Cyberpunk Flappy</title>
<meta name="color-scheme" content="dark light" />
<style>
  :root{
    --bg1:#0a0f1a; --bg2:#0b0018; --ink:#e6f0ff; --muted:#9fb0c8; --panel:#0e1726; --line:#172033;
    --pri:#ff2ea6; --sec:#00f0ff; --acc:#aaff00; --warn:#ffb000;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 60% at 50% 110%, var(--bg2), var(--bg1));color:var(--ink);
       font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Inter",sans-serif; overflow:hidden}
  .hud{position:fixed;inset:0;pointer-events:none}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;gap:8px;align-items:center;justify-content:space-between;
          padding:10px 14px;background:linear-gradient(180deg,#0008,#0000);backdrop-filter:blur(6px)}
  .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#0b1220cc;pointer-events:auto}
  .score{font-weight:700;letter-spacing:1px}
  .btn{pointer-events:auto;appearance:none;border:1px solid var(--line);background:#0b1220; color:var(--ink);
       padding:8px 12px;border-radius:10px;cursor:pointer;transition:transform .06s ease; font-weight:600}
  .btn:hover{transform:translateY(-1px)}
  .btn:active{transform:translateY(0)}
  .panel{position:absolute;right:10px;top:58px;width:min(420px,calc(100vw - 20px));max-height:calc(100vh - 78px);overflow:auto;pointer-events:auto;background:#0b1220e6;border:1px solid var(--line);border-radius:14px;padding:12px;box-shadow:0 10px 40px #000a;backdrop-filter:blur(4px)}
  .row{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:center;margin:10px 0}
  .row label{color:var(--muted)}
  select,input[type="range"],input[type="checkbox"],input[type="number"]{width:100%}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}
  .sub{font-size:12px;color:var(--muted);margin-top:-2px}
  .pill{display:inline-flex;gap:6px;border:1px dashed var(--line);padding:6px 9px;border-radius:999px;color:var(--muted)}
  .footer{position:absolute;left:10px;bottom:10px;display:flex;gap:8px;align-items:center;pointer-events:auto}
  .key{border:1px solid var(--line);padding:4px 8px;border-radius:8px;background:#0b1220cc}
  canvas{display:block;position:fixed;inset:0}
  /* CRT scanlines & vignette */
  .scanlines::after{content:"";position:fixed;inset:0;pointer-events:none;background:
      repeating-linear-gradient(to bottom, #0000 0px, #0000 2px, #0002 3px, #0000 4px)}
  .vignette::before{content:"";position:fixed;inset:-2%;pointer-events:none;border-radius:2px;
      box-shadow:inset 0 0 180px 40px #000a}
  .pixelate{image-rendering:pixelated}
</style>
</head>
<body>
<canvas id="game"></canvas>
<button id="overlayStart" class="btn" style="position:fixed;left:50%;top:42%;transform:translate(-50%,-50%);padding:14px 24px;font-size:16px;z-index:5;pointer-events:auto">Play</button>
<div class="hud scanlines vignette" id="hud">
  <div class="topbar">
    <div class="badge"><span style="width:10px;height:10px;border-radius:50%;background:var(--pri);box-shadow:0 0 12px var(--pri)"></span>
      <span style="opacity:.8">Lofi‑Cyber Flappy</span></div>
    <div style="display:flex;gap:8px;align-items:center">
      <div class="badge"><span class="score">Score: <span id="score">0</span></span></div>
      <div class="badge">Best: <span id="best">0</span></div>
      <button class="btn" id="btnStart">Start</button>
      <button class="btn" id="btnPause">Pause</button>
      <button class="btn" id="btnReset">Reset</button>
    </div>
  </div>
  <div class="panel" id="panel">
    <h3 style="margin:4px 0 6px;color:var(--pri);text-shadow:0 0 12px var(--pri)">Customization</h3>
    <div class="grid">
      <div>
        <div class="row"><label>Theme</label>
          <select id="theme">
            <option value="magenta">Neon Magenta</option>
            <option value="cyan">Electric Cyan</option>
            <option value="lime">Toxic Lime</option>
            <option value="amber">Amber Pulse</option>
          </select>
        </div>
        <div class="row"><label>Difficulty</label>
          <select id="diff">
            <option value="0">Easy</option>
            <option value="1" selected>Normal</option>
            <option value="2">Hard</option>
          </select>
        </div>
        <div class="row"><label>Gravity</label>
          <input id="gravity" type="range" min="0.1" max="1.0" step="0.02" value="0.36" />
        </div>
        <div class="row"><label>Flap Power</label>
          <input id="flap" type="range" min="3" max="10" step="0.1" value="6.2" />
        </div>
        <div class="row"><label>World Speed</label>
          <input id="speed" type="range" min="1.5" max="6" step="0.1" value="3.2" />
        </div>
        <div class="row"><label>Gap Size</label>
          <input id="gap" type="range" min="100" max="240" step="2" value="150" />
        </div>
        <div class="row"><label>Pipe Width</label>
          <input id="pipeW" type="range" min="40" max="120" step="2" value="70" />
        </div>
      </div>
      <div>
        <div class="row"><label>Scanlines</label><input id="scan" type="checkbox" checked></div>
        <div class="row"><label>Vignette</label><input id="vig" type="checkbox" checked></div>
        <div class="row"><label>Pixelate</label><input id="pix" type="checkbox"></div>
        <div class="row"><label>Particles</label><input id="particles" type="checkbox" checked></div>
        <div class="row"><label>Trail</label><input id="trail" type="checkbox" checked></div>
        <div class="row"><label>Bird Skin</label>
          <select id="skin">
            <option value="triangle">Triangle</option>
            <option value="disk">Disk</option>
            <option value="cube">Cube</option>
            <option value="ring">Ring</option>
          </select>
        </div>
        <div class="row"><label>Auto‑Balance</label><input id="autobal" type="checkbox" checked></div>
        <div class="row"><label>Mute SFX</label><input id="mute" type="checkbox"></div>
      </div>
    </div>
    <div class="sub">Changes apply immediately. Your best score & settings are saved locally.</div>
  </div>
  <div class="footer">
    <span class="pill">Controls: <span class="key">SPACE</span> / <span class="key">↑</span> / <span class="key">Click</span> / <span class="key">Tap</span></span>
  </div>
</div>
<script>
(function(){
  'use strict';
  // ---------- Helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const E = sel => document.querySelector(sel);

  const THEMES = {
    magenta:{pri:'#ff2ea6',sec:'#00f0ff',bg1:'#0a0f1a',bg2:'#0b0018'},
    cyan:{pri:'#00e5ff',sec:'#9dff00',bg1:'#06141f',bg2:'#001018'},
    lime:{pri:'#aaff00',sec:'#ff00e0',bg1:'#0b1110',bg2:'#001400'},
    amber:{pri:'#ffb000',sec:'#00ffd5',bg1:'#0f0a00',bg2:'#1a0f00'}
  };

  const defaults = {
    theme:'magenta', diff:1, gravity:0.36, flap:6.2, speed:3.2, gap:150, pipeW:70,
    scan:true, vig:true, pix:false, particles:true, trail:true, skin:'triangle', autobal:true, mute:false
  };

  // ---------- State & persistence ----------
  const saved = JSON.parse(localStorage.getItem('lofi-flappy-settings')||'null')||defaults;
  const best = +localStorage.getItem('lofi-flappy-best')||0;
  const S = {...defaults,...saved};
  let BEST = best;

  // ---------- DOM bind ----------
  E('#theme').value=S.theme; E('#diff').value=String(S.diff);
  E('#gravity').value=S.gravity; E('#flap').value=S.flap; E('#speed').value=S.speed; E('#gap').value=S.gap; E('#pipeW').value=S.pipeW;
  E('#scan').checked=S.scan; E('#vig').checked=S.vig; E('#pix').checked=S.pix; E('#particles').checked=S.particles; E('#trail').checked=S.trail;
  E('#skin').value=S.skin; E('#autobal').checked=S.autobal; E('#mute').checked=S.mute;
  E('#best').textContent = BEST;

  const hud = E('#hud');
  const canvas = E('#game');
  const ctx = canvas.getContext('2d');

  function fit(){canvas.width=innerWidth; canvas.height=innerHeight; buildCity();}
  addEventListener('resize',fit,{passive:true}); fit();

  // Apply theme to CSS
  function applyTheme(){
    const t = THEMES[S.theme]||THEMES.magenta;
    document.documentElement.style.setProperty('--pri',t.pri);
    document.documentElement.style.setProperty('--sec',t.sec);
    document.documentElement.style.setProperty('--bg1',t.bg1);
    document.documentElement.style.setProperty('--bg2',t.bg2);
    document.body.style.background = `radial-gradient(1200px 60% at 50% 110%, ${t.bg2}, ${t.bg1})`;
  }
  applyTheme();
  // Build background once per resize/theme
  function buildCity(){
    const w=canvas.width, h=canvas.height; const step=BG.step;
    const baseHeights=[90,130,170];
    for(let li=0; li<3; li++){
      const arr=[]; for(let x=-step; x<w+step; x+=step){
        const bw = 54 + li*14 + Math.floor(rand(-6,6));
        const bh = baseHeights[li] + Math.floor(rand(-24,32));
        arr.push({x, w:bw, h:bh});
      }
      BG.layers[li].b = arr;
    }
  }
  buildCity();

  function save(){ localStorage.setItem('lofi-flappy-settings', JSON.stringify(S)); }

  // ---------- Audio (tiny SFX) ----------
  let ac, masterGain; const ensureAC = ()=>{ if(!ac){ ac = new (window.AudioContext||window.webkitAudioContext)(); masterGain = ac.createGain(); masterGain.gain.value = 0.12; masterGain.connect(ac.destination);} };
  const beep = (f=440, t=0.08, type='sine')=>{ if(S.mute) return; ensureAC(); const o=ac.createOscillator(); const g=ac.createGain(); o.type=type; o.frequency.value=f; o.connect(g); g.connect(masterGain); const now=ac.currentTime; g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(1,now+0.005); g.gain.exponentialRampToValueAtTime(0.0001,now+t); o.start(now); o.stop(now+t+0.01); };

  // ---------- Game objects ----------
  const G = { running:false, time:0, score:0, passed:0, px:0, pipeTimer:0, focus:0 };
  const world = { speed:S.speed, gravity:S.gravity, gap:S.gap, pipeW:S.pipeW };
  // Background controller: persistent city layers
  const BG = {
    speeds:[0.05,0.1,0.2], // nearly static; user complained of speed
    step: 200,
    layers: [ {b:[]}, {b:[]}, {b:[]} ],
  };
  let bird = { x: innerWidth*0.3, y: innerHeight*0.5, vy: 0, r: 14, alive:true };
  let pipes = [];
  let sparks = [];
  let trailPts = [];

  function reset(soft=false){
    bird = { x: innerWidth*0.3, y: innerHeight*0.5, vy: 0, r: 14, alive:true };
    pipes.length=0; sparks.length=0; trailPts.length=0; G.score=0; G.passed=0; G.pipeTimer=0; G.focus=0;
    world.speed=S.speed; world.gravity=S.gravity; world.gap=S.gap; world.pipeW=S.pipeW;
    if(!soft) G.time=0;
    E('#score').textContent=G.score;
  }

  // Pipes
  function spawnPipe(){
    const h = canvas.height;
    const minGapTop = 60; const maxGapBottom = h-60;
    const cy = rand(minGapTop+world.gap/2, maxGapBottom-world.gap/2);
    const x = canvas.width + world.pipeW;
    pipes.push({ x, w: world.pipeW, top: cy-world.gap/2, bot: cy+world.gap/2, passed:false });
  }

  // Particles
  function addSpark(x,y,clr){ if(!S.particles) return; for(let i=0;i<4;i++){ sparks.push({x,y, vx:rand(-1,1), vy:rand(-1.6, -0.2), life:rand(0.25,0.6), t:0, c:clr}); } }

  // Input
  function flap(){ if(!G.running){ start(); return; } if(!bird.alive){ reset(); start(); return; } bird.vy = -S.flap; addSpark(bird.x-8,bird.y,'pri'); beep(660,0.06,'triangle'); }
  addEventListener('keydown',e=>{ if(['Space','ArrowUp','KeyW'].includes(e.code)){ e.preventDefault(); flap(); } if(e.code==='KeyP') togglePause(); });
  addEventListener('pointerdown', flap);

  E('#btnStart').onclick=()=>{ if(!G.running){ start(); } else { flap(); } };
  E('#overlayStart').onclick=()=>{ start(); E('#overlayStart').style.display='none'; };
  E('#btnPause').onclick=()=>togglePause();
  E('#btnReset').onclick=()=>{ reset(); drawFrame(0); beep(520,0.04,'sine'); };

  function togglePause(){ if(!G.running) return; G.running=false; }
  function start(){ try{ ensureAC(); ac&&ac.resume&&ac.resume(); }catch(e){} G.running=true; }

  // Settings listeners
  const bind = (id, fn) => E(id).addEventListener('input', fn);
  bind('#theme', e=>{ S.theme=e.target.value; applyTheme(); save(); });
  bind('#diff', e=>{ S.diff=+e.target.value; autoTuneByDiff(); save(); });
  bind('#gravity', e=>{ S.gravity=+e.target.value; world.gravity=S.gravity; save(); });
  bind('#flap', e=>{ S.flap=+e.target.value; save(); });
  bind('#speed', e=>{ S.speed=+e.target.value; world.speed=S.speed; save(); });
  bind('#gap', e=>{ S.gap=+e.target.value; world.gap=S.gap; save(); });
  bind('#pipeW', e=>{ S.pipeW=+e.target.value; world.pipeW=S.pipeW; save(); });
  bind('#scan', e=>{ S.scan=e.target.checked; hud.classList.toggle('scanlines',S.scan); save(); });
  bind('#vig', e=>{ S.vig=e.target.checked; hud.classList.toggle('vignette',S.vig); save(); });
  bind('#pix', e=>{ S.pix=e.target.checked; canvas.classList.toggle('pixelate',S.pix); save(); });
  bind('#particles', e=>{ S.particles=e.target.checked; save(); });
  bind('#trail', e=>{ S.trail=e.target.checked; if(!S.trail) trailPts.length=0; save(); });
  bind('#skin', e=>{ S.skin=e.target.value; save(); });
  bind('#autobal', e=>{ S.autobal=e.target.checked; save(); });
  bind('#mute', e=>{ S.mute=e.target.checked; save(); });

  hud.classList.toggle('scanlines',S.scan);
  hud.classList.toggle('vignette',S.vig);
  canvas.classList.toggle('pixelate',S.pix);

  function autoTuneByDiff(){
    // Set sensible baselines by difficulty
    if(S.diff===0){ S.gravity=0.32; S.flap=7.0; S.speed=2.8; S.gap=180; S.pipeW=80; }
    if(S.diff===1){ S.gravity=0.36; S.flap=6.2; S.speed=3.2; S.gap=150; S.pipeW=70; }
    if(S.diff===2){ S.gravity=0.42; S.flap=6.0; S.speed=3.8; S.gap=130; S.pipeW=64; }
    // reflect immediately
    E('#gravity').value=S.gravity; world.gravity=S.gravity; E('#flap').value=S.flap;
    E('#speed').value=S.speed; world.speed=S.speed; E('#gap').value=S.gap; world.gap=S.gap; E('#pipeW').value=S.pipeW; world.pipeW=S.pipeW;
  }

  // ---------- Drawing helpers ----------
  function neonRect(x,y,w,h,clr){ ctx.save(); ctx.fillStyle=clr; ctx.globalAlpha=0.85; ctx.fillRect(x,y,w,h); ctx.shadowColor=clr; ctx.shadowBlur=10; ctx.strokeStyle=clr; ctx.lineWidth=1.5; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1); ctx.shadowBlur=0; ctx.restore(); }
  function neonCircle(x,y,r,clr){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=clr; ctx.shadowColor=clr; ctx.shadowBlur=18; ctx.fill(); ctx.shadowBlur=0; }

  function drawBird(){
    const pri=getComputedStyle(document.documentElement).getPropertyValue('--pri').trim();
    const sec=getComputedStyle(document.documentElement).getPropertyValue('--sec').trim();
    // --- Trail in screen space (not transformed) ---
    if(S.trail){
      trailPts.push({x:bird.x,y:bird.y}); if(trailPts.length>50) trailPts.shift();
      for(let i=0;i<trailPts.length;i++){ const p=trailPts[i]; const a=1-i/trailPts.length; ctx.globalAlpha=a*0.22; neonCircle(p.x, p.y, 3, sec); }
      ctx.globalAlpha=1;
    }
    // --- Bird ---
    ctx.save(); ctx.translate(bird.x,bird.y); ctx.rotate(clamp(bird.vy,-8,8)*0.035);
    if(S.skin==='triangle'){
      ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-10,-8); ctx.lineTo(-10,8); ctx.closePath(); ctx.fillStyle=pri; ctx.shadowColor=pri; ctx.shadowBlur=14; ctx.fill(); ctx.shadowBlur=0;
    } else if(S.skin==='disk'){
      neonCircle(0,0,12,pri);
    } else if(S.skin==='cube'){
      neonRect(-10,-10,20,20,pri);
    } else if(S.skin==='ring'){
      ctx.strokeStyle=pri; ctx.lineWidth=5; ctx.shadowColor=pri; ctx.shadowBlur=14; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur=0;
    }
    ctx.restore();
  }); if(trailPts.length>70) trailPts.shift();
      for(let i=0;i<trailPts.length;i++){ const p=trailPts[i]; const a=1-i/trailPts.length; ctx.globalAlpha=a*0.22; neonCircle(p.x, p.y, 3, sec); } ctx.globalAlpha=1;
    }
    if(S.skin==='triangle'){
      ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-10,-8); ctx.lineTo(-10,8); ctx.closePath(); ctx.fillStyle=pri; ctx.shadowColor=pri; ctx.shadowBlur=14; ctx.fill(); ctx.shadowBlur=0;
    } else if(S.skin==='disk'){
      neonCircle(0,0,12,pri);
    } else if(S.skin==='cube'){
      neonRect(-10,-10,20,20,pri);
    } else if(S.skin==='ring'){
      ctx.strokeStyle=pri; ctx.lineWidth=5; ctx.shadowColor=pri; ctx.shadowBlur=14; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur=0;
    }
    ctx.restore();
  }

  function drawCity(t){
    const w=canvas.width, h=canvas.height;
    const pri=getComputedStyle(document.documentElement).getPropertyValue('--pri').trim();
    const sec=getComputedStyle(document.documentElement).getPropertyValue('--sec').trim();
    // base + subtle fog
    ctx.fillStyle = '#070a10'; ctx.fillRect(0,0,w,h);
    const g=ctx.createLinearGradient(0,h*0.52,0,h);
    g.addColorStop(0,'rgba(10,20,30,0)'); g.addColorStop(1,'rgba(10,20,30,.85)');
    ctx.fillStyle=g; ctx.fillRect(0,h*0.52,w,h*0.48);
    // horizon lines
    for(let i=0;i<3;i++){ const y=h*0.67+i*10; ctx.globalAlpha=0.05; ctx.fillStyle=sec; ctx.fillRect(0,y,w,1); ctx.globalAlpha=1; }

    const colors=['#0b1a2d','#0f223d','#152a52'];
    for(let li=0; li<3; li++){
      const L = BG.layers[li].b; ctx.fillStyle=colors[li];
      for(let i=0;i<L.length;i++){
        const b=L[i]; let x=b.x; // already updated in update()
        if(x> w+BG.step) { b.x = x - (w+BG.step*2); x=b.x; }
        ctx.fillRect(x, h-b.h, b.w, b.h);
        // sparse windows
        for(let wx=x+8; wx<x+b.w-8; wx+=12){ if(((wx*7 + (t*30|0)) % 11)===0){ ctx.globalAlpha=0.28; ctx.fillStyle = (wx%2)? pri : sec; ctx.fillRect(wx, h-b.h+8 + ((wx>>2)%8), 6, 10); ctx.fillStyle=colors[li]; ctx.globalAlpha=1; }}
      }
    }
    // ground glow
    ctx.fillStyle=pri; ctx.globalAlpha=0.22; ctx.fillRect(0,h-2,w,2); ctx.globalAlpha=1;
  }

    // Update parallax offsets here to ensure extremely slow drift
    // (independent from gameplay speed)
    // Offsets are updated inside update(dt).
    const colors=['#0b1120','#0e1426','#121a32'];
    for(let li=0; li<3; li++){
      for(let x=-BG.off[li]; x<w+BG.step; x+=BG.step){
        const bw = 50 + (li*14) + rand(-6,6);
        const bh = 90 + li*54 + rand(-24,32);
        ctx.fillStyle=colors[li]; ctx.fillRect(x, h-bh, bw, bh);
        for(let wx= x+8; wx<x+bw-8; wx+=12){ if(((wx*13+Math.floor(t*60))%9)===0){ ctx.fillStyle = Math.random()<0.55? pri: sec; ctx.globalAlpha=0.22; ctx.fillRect(wx, h-bh+8+((wx>>2)%8), 6, 10); ctx.globalAlpha=1; }}
      }
    }
    ctx.fillStyle=pri; ctx.globalAlpha=0.25; ctx.fillRect(0,h-2,w,2); ctx.globalAlpha=1;
  }
    // Parallax layers with calm, constant speed (px/sec)
    const speeds=[1.5,3,5];
    const colors=['#0b1120','#0e1426','#121a32'];
    const step=120;
    for(let li=0; li<3; li++){
      const Lspeed=speeds[li];
      for(let x=-((t*Lspeed)%step); x<w+step; x+=step){
        const bw = 50 + (li*14) + rand(-6,6);
        const bh = 90 + li*54 + rand(-24,32);
        ctx.fillStyle=colors[li]; ctx.fillRect(x, h-bh, bw, bh);
        // neon windows with twinkle
        for(let wx= x+8; wx<x+bw-8; wx+=12){ if(((wx*13+Math.floor(t*60))%7)===0){ ctx.fillStyle = Math.random()<0.55? pri: sec; ctx.globalAlpha=0.28; ctx.fillRect(wx, h-bh+8+((wx>>2)%8), 6, 10); ctx.globalAlpha=1; }}
      }
    }
    // Ground neon line
    ctx.fillStyle=pri; ctx.globalAlpha=0.25; ctx.fillRect(0,h-2,w,2); ctx.globalAlpha=1;
  }

  function drawPipes(){
    const pri=getComputedStyle(document.documentElement).getPropertyValue('--pri').trim();
    const sec=getComputedStyle(document.documentElement).getPropertyValue('--sec').trim();
    pipes.forEach(p=>{
      neonRect(p.x, 0, p.w, p.top, sec); // top
      neonRect(p.x, p.bot, p.w, canvas.height-p.bot, sec); // bottom
      // connector rings
      ctx.fillStyle=pri; ctx.globalAlpha=0.25; ctx.fillRect(p.x-4, p.top-6, p.w+8, 4); ctx.fillRect(p.x-4, p.bot+2, p.w+8, 4); ctx.globalAlpha=1;
    });
  }

  function drawSparks(dt){
    const pri=getComputedStyle(document.documentElement).getPropertyValue('--pri').trim();
    for(let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.t+=dt; s.x+=s.vx*60*dt; s.y+=s.vy*60*dt; s.vy+=world.gravity*0.4*dt*60; const a=1-s.t/s.life; if(a<=0){sparks.splice(i,1); continue;} ctx.globalAlpha=a*0.8; neonCircle(s.x,s.y,2, s.c==='pri'?pri:'#00f0ff'); ctx.globalAlpha=1; }
  }

  // ---------- Game Loop ----------
  let last=0; reset();
  function loop(ts){ const t = ts/1000; const dt = Math.min(0.033, last? t-last : 0.016); last = t; if(G.running) update(dt); drawFrame(dt,t); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  function update(dt){
    G.time += dt; G.pipeTimer += dt;
    const spawnEvery = clamp(1.4 - (S.diff*0.08), 1.1, 1.6);
    if(G.pipeTimer > spawnEvery){ G.pipeTimer = 0; spawnPipe(); }

    // Move pipes
    for(let i=pipes.length-1;i>=0;i--){ const p=pipes[i]; p.x -= world.speed*60*dt; if(p.x + p.w < 0) pipes.splice(i,1); }

    // Bird physics
    bird.vy = clamp(bird.vy + world.gravity*60*dt, -12, 12);
    bird.y += bird.vy;

    // Background drift (ultra slow)
    for(let li=0; li<3; li++){
      const arr=BG.layers[li].b; const vx = BG.speeds[li]*dt; // px/frame (very small)
      for(let i=0;i<arr.length;i++){
        arr[i].x -= vx;
        if(arr[i].x < -BG.step) arr[i].x += BG.step * arr.length;
      }
    }

    // Collisions
    const bx = bird.x, by = bird.y, r=bird.r;
    for(const p of pipes){
      if(!p.passed && p.x + p.w < bx - r){ p.passed=true; G.score++; E('#score').textContent=G.score; addSpark(bx,by,'pri'); beep(880,0.05,'square'); if(G.score>BEST){ BEST=G.score; localStorage.setItem('lofi-flappy-best', BEST); E('#best').textContent=BEST; } }
      if(bx+r>p.x && bx-r<p.x+p.w && (by-r<p.top || by+r>p.bot)) die();
    }
    if(by-r<0 || by+r>canvas.height) die();

    // Auto-balance subtle
    if(S.autobal){
      const target = 6 + S.diff*5; const rate = G.time>0 ? (G.score / (G.time/60)) : 0; const adj = clamp((rate - target)/target, -0.4, 0.4);
      world.speed = clamp(S.speed * (1 + adj*0.18), 1.8, 5.2);
      world.gap   = clamp(S.gap   * (1 - adj*0.16), 120, 240);
      world.pipeW = clamp(S.pipeW * (1 - adj*0.12), 52, 96);
    }
  }

    // Move pipes
    for(let i=pipes.length-1;i>=0;i--){ const p=pipes[i]; p.x -= world.speed*60*dt; if(p.x + p.w < 0) pipes.splice(i,1); }

    // Bird physics
    bird.vy = clamp(bird.vy + world.gravity*60*dt, -12, 12);
    bird.y += bird.vy;

    // Background ultra-slow drift (independent)
    for(let i=0;i<3;i++){ BG.off[i] += BG.speeds[i]*dt; if(BG.off[i] > BG.step) BG.off[i] -= BG.step; }

    // Collisions
    const bx = bird.x, by = bird.y, r=bird.r;
    for(const p of pipes){
      if(!p.passed && p.x + p.w < bx - r){ p.passed=true; G.score++; E('#score').textContent=G.score; addSpark(bx,by,'pri'); beep(880,0.05,'square'); if(G.score>BEST){ BEST=G.score; localStorage.setItem('lofi-flappy-best', BEST); E('#best').textContent=BEST; } }
      if(bx+r>p.x && bx-r<p.x+p.w && (by-r<p.top || by+r>p.bot)) die();
    }
    if(by-r<0 || by+r>canvas.height) die();

    // Auto-balance subtle
    if(S.autobal){
      const target = 6 + S.diff*5; const rate = G.time>0 ? (G.score / (G.time/60)) : 0; const adj = clamp((rate - target)/target, -0.4, 0.4);
      world.speed = clamp(S.speed * (1 + adj*0.18), 1.8, 5.2);
      world.gap   = clamp(S.gap   * (1 - adj*0.16), 120, 240);
      world.pipeW = clamp(S.pipeW * (1 - adj*0.12), 52, 96);
    }
  }

    // Move pipes with subpixel smoothing
    for(let i=pipes.length-1;i>=0;i--){ const p=pipes[i]; p.x -= world.speed*60*dt; if(p.x + p.w < 0) pipes.splice(i,1); }

    // Bird physics with gentle cap
    bird.vy = clamp(bird.vy + world.gravity*60*dt, -12, 12);
    bird.y += bird.vy;

    // Collisions
    const bx = bird.x, by = bird.y, r=bird.r;
    for(const p of pipes){
      if(!p.passed && p.x + p.w < bx - r){ p.passed=true; G.score++; E('#score').textContent=G.score; addSpark(bx,by,'pri'); beep(880,0.05,'square'); if(G.score>BEST){ BEST=G.score; localStorage.setItem('lofi-flappy-best', BEST); E('#best').textContent=BEST; } }
      if(bx+r>p.x && bx-r<p.x+p.w && (by-r<p.top || by+r>p.bot)) die();
    }
    if(by-r<0 || by+r>canvas.height) die();

    // Auto-balance (more subtle)
    if(S.autobal){
      const target = 6 + S.diff*5; const rate = G.time>0 ? (G.score / (G.time/60)) : 0; const adj = clamp((rate - target)/target, -0.4, 0.4);
      world.speed = clamp(S.speed * (1 + adj*0.18), 1.8, 5.2);
      world.gap   = clamp(S.gap   * (1 - adj*0.16), 120, 240);
      world.pipeW = clamp(S.pipeW * (1 - adj*0.12), 52, 96);
    }
  }

  function die(){ if(!bird.alive) return; bird.alive=false; G.running=false; addSpark(bird.x,bird.y,'pri'); addSpark(bird.x+6,bird.y-4,'pri'); beep(160,0.18,'sawtooth'); }

  function drawFrame(dt,t){
    drawCity(t||0);
    drawPipes();
    drawBird();
    drawSparks(dt||0.016);

    if(!G.running){
      const obtn = E('#overlayStart'); if(obtn) obtn.style.display='block';
      const pri=getComputedStyle(document.documentElement).getPropertyValue('--pri').trim();
      ctx.textAlign='center'; ctx.font='700 42px Inter, Segoe UI, system-ui, sans-serif'; ctx.fillStyle=pri; ctx.shadowColor=pri; ctx.shadowBlur=18;
      ctx.fillText('Tap / Space to FLAP', canvas.width/2, canvas.height*0.33); ctx.shadowBlur=0;
      ctx.font='400 16px Inter, Segoe UI, system-ui, sans-serif'; ctx.fillStyle='rgba(255,255,255,.7)';
      ctx.fillText('Avoid neon vents. Pass through gaps to score. Customize on the right.', canvas.width/2, canvas.height*0.33+28);
    } else {
      const obtn = E('#overlayStart'); if(obtn) obtn.style.display='none';
    }
  }
  }

  // ---------- Mobile friendly tweaks ----------
  addEventListener('visibilitychange', ()=>{ if(document.hidden) G.running=false; });

  // ---------- Minimal Self‑Tests (console) ----------
  (function runTests(){
    let pass=0, fail=0; const test=(name,fn)=>{ try{ fn(); console.log('%cPASS','color:#9f9',name); pass++; }catch(e){ console.error('FAIL',name,e); fail++; } };
    test('clamp()', ()=>{ if(clamp(5,0,4)!==4) throw new Error('upper'); if(clamp(-1,0,4)!==0) throw new Error('lower'); if(clamp(2,0,4)!==2) throw new Error('mid'); });
    test('spawnPipe gap within bounds', ()=>{ const old=pipes.length; spawnPipe(); const p=pipes[pipes.length-1]; if(!p) throw new Error('no pipe'); const gap=p.bot-p.top; if(Math.abs(gap-world.gap)>0.001) throw new Error('gap mismatch'); if(p.top<0||p.bot>canvas.height) throw new Error('out of bounds'); pipes.length=old; });
    test('collision check basic', ()=>{ reset(true); pipes.push({x:bird.x+bird.r-2,w:50,top:0,bot:canvas.height/2,passed:false}); bird.y = canvas.height-10; // ensures bottom collision
      const p=pipes[0]; const hit = (bird.x+bird.r>p.x && bird.x-bird.r<p.x+p.w && (bird.y-bird.r<p.top || bird.y+bird.r>p.bot)); if(!hit) throw new Error('expected hit logic false'); pipes.length=0; });
    console.log(`Self‑tests: ${pass} passed, ${fail} failed`);
    // Extra tests
    test('bg speeds very slow', ()=>{ const max = Math.max.apply(null,BG.speeds); if(max>8) throw new Error('bg too fast'); });
  })();
