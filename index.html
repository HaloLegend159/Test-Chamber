<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dither Machine — Live Background Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050712;
      --fg-card: rgba(15, 23, 42, 0.96);
      --fg-border: rgba(148, 163, 184, 0.4);
      --accent: #818cf8;
      --accent-soft: rgba(129, 140, 248, 0.12);
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --text-mute: #6b7280;
      --radius-lg: 18px;
      --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.6);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Inter", "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    /* Dither canvas: ALWAYS behind everything */
    #dither-canvas {
      position: fixed;
      inset: 0;
      z-index: 0;
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Foreground UI container */
    .ui-root {
      position: relative;
      z-index: 1;
      height: 100%;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      pointer-events: none; /* let children decide if they receive events */
    }

    .ui-shell {
      pointer-events: auto;
      max-width: 960px;
      width: 100%;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(260px, 1fr);
      gap: 20px;
      align-items: stretch;
    }

    @media (max-width: 800px) {
      .ui-shell {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      background: var(--fg-card);
      border-radius: var(--radius-lg);
      border: 1px solid var(--fg-border);
      box-shadow: var(--shadow-soft);
      padding: 16px 18px 18px;
      backdrop-filter: blur(16px);
    }

    .panel-main-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title-label {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--text-mute);
    }

    .title-main {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .title-main span {
      color: var(--accent);
    }

    .badge-soft {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      white-space: nowrap;
    }

    .panel-main-body {
      margin-top: 8px;
    }

    .subtitle {
      font-size: 13px;
      color: var(--text-soft);
      margin-bottom: 12px;
    }

    .icon-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 12px;
    }

    .icon-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      background: rgba(15, 23, 42, 0.85);
      font-size: 12px;
      color: var(--text-soft);
    }

    .icon-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-soft);
    }

    .fake-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .fake-card {
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.98);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 8px;
      min-height: 52px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 4px;
    }

    .fake-card-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-mute);
    }

    .fake-card-value {
      font-size: 13px;
      color: var(--text-soft);
    }

    @media (max-width: 640px) {
      .fake-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    /* Control panel on the right */
    .panel-controls h3 {
      margin: 0 0 8px;
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-soft);
    }

    .panel-controls p {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--text-mute);
    }

    .control-group {
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
    }

    .control-group label {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: var(--text-soft);
    }

    .control-group label span.value {
      color: var(--accent);
      font-variant-numeric: tabular-nums;
    }

    .control-group input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .hint {
      margin-top: 6px;
      font-size: 11px;
      color: var(--text-mute);
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .pill-chip {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
      font-size: 11px;
      padding: 4px 7px;
      color: var(--text-soft);
    }

    .pill-chip.good {
      border-color: rgba(52, 211, 153, 0.7);
      color: #a7f3d0;
    }

    .no-webgl-message {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-soft);
      font-size: 13px;
      z-index: 2;
    }

    .no-webgl-message strong {
      color: var(--accent);
    }

    .no-webgl .no-webgl-message {
      display: flex;
    }
  </style>
</head>
<body>
  <canvas id="dither-canvas"></canvas>

  <div class="ui-root">
    <div class="ui-shell panel-main">
      <div class="panel">
        <div class="panel-main-header">
          <div class="title-block">
            <div class="title-label">Background Engine</div>
            <div class="title-main">
              Dither <span>Machine</span>
            </div>
          </div>
          <div class="badge-soft">Foreground stays clean</div>
        </div>
        <div class="panel-main-body">
          <p class="subtitle">
            This is the actual <strong>Type A animated dither</strong> running behind everything.
            Notice how the foreground UI stays crisp and readable while the dots flow smoothly in the back.
          </p>

          <div class="icon-row">
            <div class="icon-pill">
              <div class="icon-dot"></div>
              <span>GPU halftone / dither</span>
            </div>
            <div class="icon-pill">
              <span>Soft pastel palette</span>
            </div>
            <div class="icon-pill">
              <span>Organic gradient drift</span>
            </div>
          </div>

          <div class="fake-grid">
            <div class="fake-card">
              <div class="fake-card-title">Mode</div>
              <div class="fake-card-value">Animated halftone dots</div>
            </div>
            <div class="fake-card">
              <div class="fake-card-title">Layer</div>
              <div class="fake-card-value">Full-screen background</div>
            </div>
            <div class="fake-card">
              <div class="fake-card-title">Brightness</div>
              <div class="fake-card-value">Low &amp; easy on eyes</div>
            </div>
            <div class="fake-card">
              <div class="fake-card-title">Seams</div>
              <div class="fake-card-value">Procedural / seamless</div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel panel-controls">
        <h3>Dither Controls</h3>
        <p>
          These sliders control the <strong>live shader</strong>.  
          Try bigger dots + slow flow for a Discord-style background.
        </p>

        <div class="control-group">
          <label>
            Dot size
            <span class="value" id="dotSizeVal"></span>
          </label>
          <input id="dotSize" type="range" min="35" max="140" value="80" />
        </div>

        <div class="control-group">
          <label>
            Dot density
            <span class="value" id="dotDensityVal"></span>
          </label>
          <input id="dotDensity" type="range" min="20" max="60" value="40" />
        </div>

        <div class="control-group">
          <label>
            Flow speed
            <span class="value" id="flowSpeedVal"></span>
          </label>
          <input id="flowSpeed" type="range" min="10" max="60" value="25" />
        </div>

        <div class="hint">
          Foreground UI is not dithered at all — this is exactly the layering you’d use for a web game.
        </div>

        <div class="pill-row">
          <div class="pill-chip good">Background-only dither ✔</div>
          <div class="pill-chip">Soft blues &amp; purples</div>
          <div class="pill-chip">No harsh color clash</div>
        </div>
      </div>
    </div>

    <div class="no-webgl-message">
      <div>
        <strong>WebGL not available.</strong><br />
        The Dither Machine needs WebGL to run its animated background.  
        Try another browser or enable hardware acceleration.
      </div>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("dither-canvas");
      const body = document.body;

      const dotSizeInput = document.getElementById("dotSize");
      const dotDensityInput = document.getElementById("dotDensity");
      const flowSpeedInput = document.getElementById("flowSpeed");
      const dotSizeVal = document.getElementById("dotSizeVal");
      const dotDensityVal = document.getElementById("dotDensityVal");
      const flowSpeedVal = document.getElementById("flowSpeedVal");

      // Initial UI readout
      function updateLabels() {
        dotSizeVal.textContent = dotSizeInput.value;
        dotDensityVal.textContent = dotDensityInput.value;
        flowSpeedVal.textContent = (flowSpeedInput.value / 10).toFixed(1);
      }
      updateLabels();

      let gl =
        canvas.getContext("webgl", { antialias: false, depth: false }) ||
        canvas.getContext("experimental-webgl", {
          antialias: false,
          depth: false,
        });

      if (!gl) {
        body.classList.add("no-webgl");
        return;
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const width = Math.floor(window.innerWidth * dpr * 0.85); // small perf win
        const height = Math.floor(window.innerHeight * dpr * 0.85);
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      const vertexSrc = `
        attribute vec2 a_position;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      const fragmentSrc = `
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_dotScale;
        uniform float u_density;
        uniform float u_flowSpeed;

        // Basic 2D value noise
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }

        float fbm(vec2 p) {
          float v = 0.0;
          float a = 0.5;
          for (int i = 0; i < 4; i++) {
            v += a * noise(p);
            p *= 2.1;
            a *= 0.5;
          }
          return v;
        }

        void main() {
          vec2 uv = gl_FragCoord.xy / u_resolution.xy;
          // keep aspect more square-ish
          uv.x *= u_resolution.x / u_resolution.y;

          float t = u_time * 0.001 * u_flowSpeed;

          // Warp UV with low freq noise to create organic drift
          vec2 warp = vec2(
            fbm(uv * 1.6 + vec2(0.0, t * 0.15)),
            fbm(uv * 1.4 - vec2(t * 0.12, 0.0))
          );
          vec2 p = uv + (warp - 0.5) * 0.18;

          // Gradient driver
          float g = 0.5 + 0.5 * sin(
            t * 0.18 +
            p.x * 2.0 +
            fbm(p * 2.3 + vec2(0.0, t * 0.22)) * 2.2
          );
          g = smoothstep(0.15, 0.95, g);

          // Soft pastel palette (Discordish but tame)
          vec3 c1 = vec3(0.03, 0.04, 0.10);       // base dark
          vec3 c2 = vec3(0.27, 0.35, 0.78);       // soft indigo
          vec3 c3 = vec3(0.23, 0.79, 0.87);       // teal accent

          vec3 grad = mix(c1, c2, g);
          grad = mix(grad, c3, 0.26 * fbm(p * 1.5 - vec2(t * 0.08, 0.0)));

          // Halftone-like dots: project onto grid
          float scale = u_dotScale;  // how many cells across
          vec2 gridUV = p * scale;

          // optional subtle motion in the grid itself
          gridUV += vec2(
            fbm(p * 3.2 + vec2(t * 0.05, 0.0)),
            fbm(p * 3.2 + vec2(0.0, t * 0.04))
          ) * 0.5;

          vec2 cell = floor(gridUV) + 0.5;
          vec2 diff = gridUV - cell;
          float dist = length(diff);

          // Dot radius controlled by gradient + density
          float minR = 0.10;
          float maxR = clamp(0.55 - u_density * 0.004, 0.18, 0.55);
          float radius = mix(minR, maxR, g);

          // Smooth dot edge
          float edgeSoft = 0.14;
          float mask = smoothstep(radius, radius - edgeSoft, dist);

          // Slight noise to break perfect circles
          float n = fbm(gridUV * 1.5 + vec2(t * 0.12, 0.0));
          mask *= 0.8 + 0.2 * n;

          // Final color: dots over dark base
          vec3 base = c1;
          vec3 color = mix(base, grad, mask);

          // Soft vignette so edges are darker / calmer
          vec2 center = uv - 0.5;
          float vignette = smoothstep(0.85, 0.25, length(center));
          color *= vignette;

          gl_FragColor = vec4(color, 1.0);
        }
      `;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function createProgram(gl, vsSource, fsSource) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        if (!vs || !fs) return null;

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("Program link error:", gl.getProgramInfoLog(program));
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      const program = createProgram(gl, vertexSrc, fragmentSrc);
      if (!program) {
        body.classList.add("no-webgl");
        return;
      }

      gl.useProgram(program);

      const positionLoc = gl.getAttribLocation(program, "a_position");
      const uResolutionLoc = gl.getUniformLocation(program, "u_resolution");
      const uTimeLoc = gl.getUniformLocation(program, "u_time");
      const uDotScaleLoc = gl.getUniformLocation(program, "u_dotScale");
      const uDensityLoc = gl.getUniformLocation(program, "u_density");
      const uFlowSpeedLoc = gl.getUniformLocation(program, "u_flowSpeed");

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // Fullscreen quad
      const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.STENCIL_TEST);
      gl.disable(gl.BLEND);

      let startTime = performance.now();

      function render() {
        resizeCanvas();
        gl.viewport(0, 0, canvas.width, canvas.height);

        const now = performance.now();
        const time = now - startTime;

        gl.useProgram(program);
        gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
        gl.uniform1f(uTimeLoc, time);

        // Map slider values to uniforms
        const dotScale = parseFloat(dotSizeInput.value);
        const density = parseFloat(dotDensityInput.value);
        const flowSpeed = parseFloat(flowSpeedInput.value) / 10.0;

        gl.uniform1f(uDotScaleLoc, dotScale);
        gl.uniform1f(uDensityLoc, density);
        gl.uniform1f(uFlowSpeedLoc, flowSpeed);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }

      dotSizeInput.addEventListener("input", updateLabels);
      dotDensityInput.addEventListener("input", updateLabels);
      flowSpeedInput.addEventListener("input", updateLabels);

      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
