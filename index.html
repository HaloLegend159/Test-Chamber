<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room-Boss Gauntlet</title>
<meta name="color-scheme" content="dark light" />
<style>
  :root{
    --bg:#0b1020; --panel:#0f172a; --ink:#e6edf7; --muted:#9fb3c8; --accent:#6ee7b7; --danger:#fca5a5; --warn:#fde68a; --border:#1f2a44;
    --radius:16px; --gap:14px; --shadow:0 8px 30px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:linear-gradient(180deg,var(--bg),#0b132b); color:var(--ink); font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:18px}
  .hud{
    display:grid; gap:var(--gap);
    grid-template-columns: 1.2fr 1fr;
  }
  .panel{
    background:rgba(15,23,42,.8); border:1px solid var(--border); border-radius:var(--radius);
    box-shadow:var(--shadow); padding:16px;
  }
  .title{display:flex;justify-content:space-between;align-items:center;margin:0 0 8px}
  .title h2{margin:0;font-size:18px}
  .tag{font-size:12px;color:var(--muted)}
  .stats{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
  .bar{height:10px;background:#11203e;border-radius:999px;overflow:hidden;border:1px solid #1b2b4c}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,#60a5fa,#34d399)}
  .grid{display:grid; gap:var(--gap)}
  .grid.two{grid-template-columns:1fr 1fr}
  .btn{
    display:inline-flex;gap:8px;align-items:center;justify-content:center;
    border:1px solid var(--border); background:#111b34; color:var(--ink);
    padding:12px 14px; border-radius:12px; cursor:pointer; user-select:none;
    transition:.15s transform,.15s background,.15s border-color;
  }
  .btn:hover{transform:translateY(-1px); background:#0f1a33}
  .btn:disabled{opacity:.5; cursor:not-allowed; transform:none}
  .btn.primary{border-color:#214b3f;background:#0f2b24}
  .btn.warn{border-color:#4b3f21;background:#2b210f}
  .btn.danger{border-color:#4b2121;background:#2b0f0f}
  .row{display:flex; gap:10px; flex-wrap:wrap}
  .choice{display:grid; gap:10px}
  .log{height:220px; overflow:auto; background:#0b152c; border:1px solid #122345; border-radius:12px; padding:10px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .log p{margin:0 0 6px; color:#c6d4e2}
  .pill{
    display:inline-flex;align-items:center;gap:6px; padding:3px 8px; border-radius:999px; border:1px solid #234;
    background:#0e1c34; color:#a7bed4; font-size:12px
  }
  .k{color:#a7ffcb}
  .small{font-size:12px;color:var(--muted)}
  .sp{height:10px}
  .ability{
    display:flex; flex-direction:column; gap:6px; padding:10px; border:1px dashed #2a3b60; border-radius:10px;
    background:#0a162f;
  }
  .footer{margin-top:14px; color:var(--muted); font-size:12px}
  @media (max-width:900px){
    .hud{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <section class="panel">
      <div class="title">
        <h2>Player</h2>
        <div class="row">
          <span class="pill">Cycle <b id="cycle">1</b></span>
          <span class="pill">Room <b id="room">1</b></span>
          <span class="pill">Bosses <b id="bosses">0</b>/3</span>
        </div>
      </div>
      <div class="stats">
        <div>
          <div>HP: <b id="php">100 / 100</b></div>
          <div class="bar"><i id="phpbar" style="width:100%"></i></div>
        </div>
        <div>
          <div>XP: <b id="xp">0</b></div>
          <div class="bar"><i id="xpbar" style="width:0%"></i></div>
        </div>
        <div>ATK: <b id="atk">10</b></div>
        <div>DEF: <b id="def">3</b></div>
        <div>CRIT: <b id="crit">10%</b></div>
        <div>SPD: <b id="spd">10</b></div>
      </div>
      <div class="sp"></div>
      <div>
        <div class="row" id="abilitiesRow"><!-- abilities injected --></div>
        <div class="small">Tip: Use keys <b>1/2/3</b> to pick choices. Abilities show cooldowns.</div>
      </div>
    </section>

    <section class="panel">
      <div class="title">
        <h2 id="stageTitle">Choose an enemy</h2>
        <span class="tag" id="stageTag">Plan your next fight</span>
      </div>
      <div id="stageArea" class="grid"></div>
    </section>
  </div>

  <section class="panel" style="margin-top:14px">
    <div class="title"><h2>Battle Log</h2><span class="tag">What just happened</span></div>
    <div class="log" id="log"></div>
    <div class="footer">© Your mini roguelite loop | No data leaves your browser.</div>
  </section>
</div>

<script>
(() => {
  // --- Utilities ---
  const $ = sel => document.querySelector(sel);
  const el = (tag, props={}, children=[]) => {
    const n = document.createElement(tag);
    Object.entries(props).forEach(([k,v])=>{
      if(k==='class') n.className=v;
      else if(k==='text') n.textContent=v;
      else if(k.startsWith('on')) n.addEventListener(k.slice(2).toLowerCase(), v);
      else n.setAttribute(k,v);
    });
    children.forEach(c => n.appendChild(c));
    return n;
  };
  const rng = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  // --- Game State ---
  const state = {
    cycle: 1,          // cycles of rooms+boss
    room: 1,           // regular rooms within a cycle
    bossesDefeated: 0,
    finalBossesNeeded: 3, // after 3 bosses, next is Final Boss
    roomsPerCycle: 3,  // rooms before a boss
    player: {
      maxHp: 100, hp: 100, atk: 10, def: 3, crit: 10, spd: 10,
      xp: 0, abilities: [], cooldowns: {}
    },
    enemy: null,
    phase: 'choose-enemy', // other: 'fight', 'buffs', 'boss', 'final'
    lock:false
  };

  // --- Abilities granted by bosses ---
  const ABILITIES = [
    {
      id:'whirlwind', name:'Whirlwind', desc:'Deal 80% ATK damage twice.',
      cd:3, use: (ctx)=> {
        const dmg1 = calcDamage(ctx.player.atk*0.8, ctx.enemy.def, ctx.player.crit);
        const dmg2 = calcDamage(ctx.player.atk*0.8, ctx.enemy.def, ctx.player.crit);
        ctx.enemy.hp = Math.max(0, ctx.enemy.hp - (dmg1+dmg2));
        log(`You spin into a <span class="k">Whirlwind</span> for ${dmg1+dmg2} total damage.`);
      }
    },
    {
      id:'arcane_shield', name:'Arcane Shield', desc:'Gain 30% of max HP as a barrier for 3 turns.',
      cd:4, use: (ctx)=> {
        const val = Math.floor(ctx.player.maxHp * 0.3);
        ctx.player.shield = Math.max(ctx.player.shield||0, val);
        ctx.player.shieldTurns = 3;
        log(`You conjure <span class="k">Arcane Shield</span> absorbing ${val} damage for 3 turns.`);
      }
    },
    {
      id:'time_warp', name:'Time Warp', desc:'Take an immediate extra turn.',
      cd:5, use: (ctx)=> {
        ctx.extraTurn = true;
        log(`You bend time with <span class="k">Time Warp</span> and act again!`);
      }
    },
    {
      id:'overcharge', name:'Overcharge', desc:'Double ATK this turn.',
      cd:4, use: (ctx)=> {
        ctx.tempAtkBoost = (ctx.tempAtkBoost||0) + ctx.player.atk; // +100% this turn
        log(`You surge with <span class="k">Overcharge</span>! ATK doubled for this strike.`);
      }
    },
    {
      id:'vamp_bite', name:'Vampiric Bite', desc:'Deal 120% ATK and heal for 50% of damage dealt.',
      cd:4, use: (ctx)=> {
        const dmg = calcDamage(ctx.player.atk*1.2, ctx.enemy.def, ctx.player.crit);
        ctx.enemy.hp = Math.max(0, ctx.enemy.hp - dmg);
        const heal = Math.floor(dmg*0.5);
        healPlayer(heal);
        log(`You drain with <span class="k">Vampiric Bite</span> for ${dmg} and heal ${heal}.`);
      }
    }
  ];

  // --- Buff pool (for post-room rewards) ---
  const BUFFS = [
    {id:'hp10', name:'+10% Max HP', apply:()=>{ const add=Math.floor(state.player.maxHp*0.10); state.player.maxHp+=add; state.player.hp+=add; }},
    {id:'atk6', name:'+6 ATK', apply:()=>{ state.player.atk+=6; }},
    {id:'def3', name:'+3 DEF', apply:()=>{ state.player.def+=3; }},
    {id:'crit8', name:'+8% CRIT', apply:()=>{ state.player.crit = clamp(state.player.crit+8,0,100); }},
    {id:'spd5', name:'+5 SPD', apply:()=>{ state.player.spd+=5; }},
    {id:'heal20', name:'Heal 20% HP now', apply:()=>{ healPlayer(Math.floor(state.player.maxHp*0.2)); }},
    {id:'barrier', name:'Start next fight with 15 Shield', apply:()=>{ state.player.nextShield = (state.player.nextShield||0)+15; }},
    {id:'vigor', name:'+10% damage this cycle', apply:()=>{ state.player.cycleDmg = (state.player.cycleDmg||0)+0.10; }},
    {id:'guard', name:'-10% damage taken this cycle', apply:()=>{ state.player.cycleDR = (state.player.cycleDR||0)+0.10; }},
  ];

  // --- Enemy templates ---
  const ENEMY_TYPES = [
    { id:'swarmer', name:'Swarmer', desc:'Fast, low HP, light hits.', scale:(lvl)=>({
      maxHp: 50 + lvl*12, atk: 7 + lvl*2, def: 2 + Math.floor(lvl*0.6), spd: 14 + Math.floor(lvl*0.7)
    })},
    { id:'brute', name:'Brute', desc:'Slow, high HP, heavy hits.', scale:(lvl)=>({
      maxHp: 110 + lvl*20, atk: 12 + lvl*4, def: 5 + Math.floor(lvl*1.2), spd: 7 + Math.floor(lvl*0.3)
    })},
    { id:'mage', name:'Arcanist', desc:'Glass cannon, crit happy.', scale:(lvl)=>({
      maxHp: 70 + lvl*14, atk: 14 + lvl*4, def: 3 + Math.floor(lvl*0.8), spd: 10 + Math.floor(lvl*0.6), crit: 20 + Math.floor(lvl*1.5)
    })},
  ];

  function bossStats(lvl){
    return {
      name: `Boss ${lvl}`,
      maxHp: 220 + lvl*70, atk: 18 + lvl*6, def: 6 + Math.floor(lvl*1.5), spd: 10 + lvl, crit: 15 + lvl*2,
      special: lvl%2? 'Crushing Blow (+50% ATK every 3 turns)':'Arcane Barrage (2x hits every 3 turns)'
    };
  }
  function finalBoss(){
    return {
      name:'FINAL BOSS — The Shard Eater',
      maxHp: 800, atk: 35, def: 12, spd: 14, crit: 20, special:'Devour: every 4th turn steals 10% of your max HP'
    };
  }

  // --- UI helpers ---
  const stageTitle = $('#stageTitle'), stageTag=$('#stageTag'), stageArea=$('#stageArea');
  const php=$('#php'), phpbar=$('#phpbar'), xp=$('#xp'), xpbar=$('#xpbar');
  const atk=$('#atk'), def=$('#def'), crit=$('#crit'), spd=$('#spd');
  const cycleEl=$('#cycle'), roomEl=$('#room'), bossesEl=$('#bosses');
  const abilitiesRow=$('#abilitiesRow');
  const logBox=$('#log');

  function log(html){
    const p = el('p'); p.innerHTML = html;
    logBox.appendChild(p);
    logBox.scrollTop = logBox.scrollHeight;
  }

  function refreshHUD(){
    const p = state.player;
    php.textContent = `${p.hp} / ${p.maxHp}`;
    phpbar.style.width = `${Math.round(100*p.hp/p.maxHp)}%`;
    xp.textContent = p.xp;
    xpbar.style.width = `${Math.min(100, p.xp%100)}%`;
    atk.textContent = Math.round(p.atk);
    def.textContent = Math.round(p.def);
    crit.textContent = `${Math.round(p.crit)}%`;
    spd.textContent = Math.round(p.spd);
    cycleEl.textContent = state.cycle;
    roomEl.textContent = state.room;
    bossesEl.textContent = state.bossesDefeated;
    renderAbilities();
  }

  function setStage(title, tag){
    stageTitle.textContent = title;
    stageTag.textContent = tag;
    stageArea.innerHTML = '';
  }

  function makeChoiceButtons(options){
    // options: [{label, class, onClick, hotkey}]
    const grid = el('div', {class:'grid two'});
    options.forEach((opt,i)=>{
      const btn = el('button', {class:`btn ${opt.class||''}`, text: opt.label});
      btn.addEventListener('click', opt.onClick);
      grid.appendChild(btn);
      // hotkeys
      const hk = (i+1).toString();
      if(!opt.hotkeyDisabled){
        document.addEventListener('keydown', function handler(e){
          if(state.lock) return;
          if(e.key===hk){
            e.preventDefault();
            btn.click();
          }
        }, {once:true});
      }
    });
    return grid;
  }

  function renderAbilities(){
    abilitiesRow.innerHTML='';
    const p = state.player;
    if(!p.abilities.length){
      abilitiesRow.appendChild(el('span',{class:'pill',text:'No abilities yet — defeat a boss!'}));
      return;
    }
    p.abilities.forEach(abil=>{
      const cdLeft = p.cooldowns[abil.id]||0;
      const wrap = el('div',{class:'ability'});
      wrap.appendChild(el('div',{text:abil.name}));
      wrap.appendChild(el('div',{class:'small',text:abil.desc}));
      const btn = el('button',{class:'btn primary', text: cdLeft?`Cooldown: ${cdLeft}`:'Use'});
      btn.disabled = !!cdLeft || state.lock || state.phase!=='fight';
      btn.addEventListener('click', ()=> useAbility(abil));
      wrap.appendChild(btn);
      abilitiesRow.appendChild(wrap);
    });
  }

  function healPlayer(n){
    const p=state.player; const before=p.hp;
    p.hp = clamp(p.hp + n, 0, p.maxHp);
    log(`Healed ${p.hp-before} HP.`);
  }

  function calcDamage(atk, def, critChance){
    const base = Math.max(1, Math.floor(atk - def*0.6));
    const variance = rng(-2,2);
    const crit = (rng(1,100) <= Math.round(critChance||0));
    return Math.max(1, Math.floor((base+variance) * (crit?1.75:1)));
  }

  function applyIncomingDamage(amount){
    const p=state.player;
    // damage reduction buffs
    const dr = p.cycleDR||0;
    let dmg = Math.floor(amount * (1 - dr));
    // shield
    if(p.shield && p.shield>0){
      const absorbed = Math.min(p.shield, dmg);
      p.shield -= absorbed; dmg -= absorbed;
      log(`Your shield absorbs ${absorbed} damage. (${p.shield||0} left)`);
    }
    p.hp = Math.max(0, p.hp - dmg);
    return dmg;
  }

  function endTurnTick(){
    const p=state.player;
    // decay shield turns
    if(p.shieldTurns!=null){
      p.shieldTurns--;
      if(p.shieldTurns<=0){ p.shield=0; p.shieldTurns=null; log(`Your Arcane Shield fades.`); }
    }
    // reduce ability cooldowns
    for(const k of Object.keys(p.cooldowns)){
      if(p.cooldowns[k]>0) p.cooldowns[k]--;
    }
  }

  // --- Flow ---
  function startGame(){
    state.cycle=1; state.room=1; state.bossesDefeated=0;
    Object.assign(state.player, {maxHp:100,hp:100,atk:10,def:3,crit:10,spd:10,xp:0,abilities:[],cooldowns:{},shield:0,shieldTurns:null,nextShield:0,cycleDmg:0,cyleDR:0});
    logBox.innerHTML='';
    log(`<b>Welcome!</b> Choose an enemy type, win, pick a buff. Every ${state.roomsPerCycle} rooms, face a boss for a new ability. Defeat ${state.finalBossesNeeded} bosses, then conquer the Final Boss.`);
    showEnemyChoice();
    refreshHUD();
  }

  function showEnemyChoice(){
    state.phase='choose-enemy';
    setStage('Pick your next fight', 'Swarmer / Brute / Arcanist');
    const opts = ENEMY_TYPES.map(t=>{
      return {
        label:`${t.name} — ${t.desc}`,
        class:'',
        onClick:()=> spawnEnemy(t)
      };
    });
    stageArea.appendChild(makeChoiceButtons(opts));
  }

  function spawnEnemy(template){
    const lvl = (state.cycle-1)*state.roomsPerCycle + state.room;
    const scaled = template.scale(lvl);
    state.enemy = {
      name: template.name,
      maxHp: scaled.maxHp, hp: scaled.maxHp,
      atk: scaled.atk, def: scaled.def, spd: scaled.spd, crit: scaled.crit||10,
      type: template.id, turn:0, boss:false
    };
    if(state.player.nextShield){ state.player.shield=(state.player.shield||0)+state.player.nextShield; state.player.shieldTurns=3; state.player.nextShield=0; log(`You start with a carryover shield.`); }
    startFight();
  }

  function spawnBoss(){
    const lvl = state.bossesDefeated+1;
    const b = bossStats(lvl);
    state.enemy = { name:b.name, maxHp:b.maxHp, hp:b.maxHp, atk:b.atk, def:b.def, spd:b.spd, crit:b.crit, turn:0, boss:true, special:b.special };
    if(state.player.nextShield){ state.player.shield=(state.player.shield||0)+state.player.nextShield; state.player.shieldTurns=3; state.player.nextShield=0; log(`You start with a carryover shield.`); }
    state.phase='boss';
    startFight(true);
  }

  function spawnFinalBoss(){
    const b = finalBoss();
    state.enemy = { name:b.name, maxHp:b.maxHp, hp:b.maxHp, atk:b.atk, def:b.def, spd:b.spd, crit:b.crit, turn:0, boss:true, final:true, special:b.special };
    if(state.player.nextShield){ state.player.shield=(state.player.shield||0)+state.player.nextShield; state.player.shieldTurns=3; state.player.nextShield=0; log(`You start with a carryover shield.`); }
    state.phase='final';
    startFight(true);
  }

  function startFight(isBoss){
    setStage(`${isBoss? (state.enemy.final?'Final Boss':'Boss') : state.enemy.name} — Fight!`, isBoss?(state.enemy.special||'A dangerous foe'):state.enemy.name);
    renderFightUI();
    log(`<b>${isBoss? (state.enemy.final?'Final Boss':'Boss'):state.enemy.name} appears!</b>`);
  }

  function renderFightUI(){
    stageArea.innerHTML='';
    const enemy = state.enemy;
    const enemyCard = el('div',{class:'panel'},[
      el('div',{class:'title'},[
        el('h2',{text: enemy.name}),
        el('span',{class:'tag',text:`HP ${enemy.hp} / ${enemy.maxHp}`})
      ]),
      el('div',{class:'bar'},[ el('i',{style:`width:${Math.round(100*enemy.hp/enemy.maxHp)}%`}) ]),
      el('div',{class:'small',text: enemy.boss? (enemy.special||''): `Type: ${enemy.type} | ATK ${enemy.atk} DEF ${enemy.def} SPD ${enemy.spd}`})
    ]);
    const actions = el('div',{class:'choice'});
    const atkBtn = el('button',{class:'btn primary', text:'Attack (basic)'},
      );
    atkBtn.addEventListener('click',()=> playerTurnBasic());
    const defendBtn = el('button',{class:'btn', text:'Defend (+50% DEF this turn)'},
      );
    defendBtn.addEventListener('click',()=> playerDefend());
    const row = el('div',{class:'row'},[atkBtn, defendBtn]);
    actions.appendChild(row);

    stageArea.appendChild(enemyCard);
    stageArea.appendChild(actions);
    renderAbilities(); // enable ability buttons for fight phase
  }

  function playerTurnBasic(extra=false){
    if(state.lock) return;
    actionLock(true);
    const ctx = {player:state.player, enemy:state.enemy};
    // apply temp buffs from abilities (one-turn)
    let atkValue = state.player.atk + (state.tempAtkBoost||0);
    if(state.player.cycleDmg) atkValue *= (1 + state.player.cycleDmg);
    const dmg = calcDamage(atkValue, state.enemy.def, state.player.crit);
    state.enemy.hp = Math.max(0, state.enemy.hp - dmg);
    log(`You strike for ${dmg} damage.`);
    state.tempAtkBoost=0;

    setTimeout(()=>{
      if(checkEnd()) { actionLock(false); return; }
      enemyAct().then(()=>{ actionLock(false); });
    }, 280);
  }

  function playerDefend(){
    if(state.lock) return;
    actionLock(true);
    const savedDef = state.player.def;
    state.player.def = Math.floor(state.player.def*1.5) + 4;
    log(`You brace yourself, boosting DEF this turn.`);
    setTimeout(()=>{
      enemyAct().then(()=>{
        state.player.def = savedDef;
        log(`Your defensive stance ends.`);
        actionLock(false);
      });
    }, 220);
  }

  function useAbility(abil){
    if(state.lock || (state.player.cooldowns[abil.id]||0)>0) return;
    actionLock(true);
    const ctx = {player:state.player, enemy:state.enemy};
    abil.use(ctx);
    state.player.cooldowns[abil.id] = abil.cd;
    refreshHUD();
    setTimeout(()=>{
      if(ctx.extraTurn){
        ctx.extraTurn=false;
        // grant immediate extra turn (no enemy act)
        actionLock(false);
        renderFightUI();
      } else {
        if(checkEnd()){ actionLock(false); return; }
        enemyAct().then(()=> actionLock(false));
      }
    },250);
  }

  async function enemyAct(){
    const e = state.enemy; e.turn++;
    // Boss specials on cadence
    let multi = 1; let modAtk = e.atk; let note='';
    if(e.boss && !e.final && e.turn%3===0){
      if((state.bossesDefeated+1)%2===1){ modAtk = Math.floor(e.atk*1.5); note='(Crushing Blow)'; }
      else { multi=2; note='(Arcane Barrage)'; }
    }
    if(e.final && e.turn%4===0){
      // Devour
      const steal = Math.floor(state.player.maxHp*0.10);
      applyIncomingDamage(steal);
      e.hp = Math.min(e.maxHp, e.hp + Math.floor(steal*0.5));
      log(`<span class="k">Devour</span> steals ${steal} HP and heals the boss.`);
      if(state.player.hp<=0){ refreshHUD(); checkEnd(); return; }
    }

    for(let i=0;i<multi;i++){
      const dmg = calcDamage(modAtk, state.player.def, e.crit||10);
      const taken = applyIncomingDamage(dmg);
      log(`${e.name} hits you for ${taken} ${note}`);
      if(state.player.hp<=0) break;
    }

    endTurnTick();
    refreshHUD();
    checkEnd();
  }

  function checkEnd(){
    const p=state.player, e=state.enemy;
    if(p.hp<=0){
      setStage('Defeat','Try again?');
      stageArea.appendChild(makeChoiceButtons([
        {label:'Restart', class:'danger', onClick:()=>startGame()}
      ]));
      log(`<b>You were defeated.</b>`);
      state.phase='end';
      return true;
    }
    if(e.hp<=0){
      log(`<b>${e.name} is defeated!</b>`);
      p.xp += e.boss ? 40 : 15;
      // after a fight:
      if(e.boss){
        if(e.final){
          setStage('Victory!','You defeated the Final Boss!');
          stageArea.appendChild(makeChoiceButtons([
            {label:'Play Again', class:'primary', onClick:()=>startGame()}
          ]));
          state.phase='end';
          return true;
        } else {
          state.bossesDefeated++;
          // choose an ability (3 random unique)
          showAbilityRewards();
        }
      } else {
        // choose a buff (3 random unique)
        showBuffRewards();
      }
      return true;
    }
    return false;
  }

  function showBuffRewards(){
    state.phase='buffs';
    setStage('Choose a Buff','Pick 1 of 3');
    const picks = pickUnique(BUFFS,3);
    const buttons = picks.map((b,i)=>({
      label: b.name,
      class: (i===0?'primary': i===1?'warn':'' ),
      onClick: ()=> {
        b.apply();
        refreshHUD();
        // advance room/boss logic
        if(state.room>=state.roomsPerCycle){
          // boss time
          if(state.bossesDefeated>=state.finalBossesNeeded){
            spawnFinalBoss();
          } else {
            setTimeout(spawnBoss, 50);
          }
          state.room=1;
          state.cycle++;
        } else {
          state.room++;
          setTimeout(showEnemyChoice, 50);
        }
      }
    }));
    stageArea.appendChild(makeChoiceButtons(buttons));
  }

  function showAbilityRewards(){
    state.phase='ability-reward';
    setStage('Choose a New Ability','Granted by the boss (pick 1)');
    const pool = ABILITIES.filter(a => !state.player.abilities.find(x=>x.id===a.id));
    const picks = pickUnique(pool.length>=3?pool:ABILITIES,3);
    const buttons = picks.map((a,i)=>({
      label: `${a.name} — ${a.desc}`,
      class: (i===0?'primary': i===1?'warn':'' ),
      onClick: ()=> {
        state.player.abilities.push(a);
        state.player.cooldowns[a.id]=0;
        refreshHUD();
        // next cycle start
        if(state.bossesDefeated>=state.finalBossesNeeded){
          spawnFinalBoss();
        } else {
          showEnemyChoice();
        }
      }
    }));
    stageArea.appendChild(makeChoiceButtons(buttons));
  }

  function pickUnique(arr, n){
    const copy=[...arr]; const out=[];
    while(copy.length && out.length<n){
      const i = rng(0, copy.length-1);
      out.push(copy.splice(i,1)[0]);
    }
    return out;
  }

  function actionLock(v){
    state.lock = v;
    // disable buttons in stage
    stageArea.querySelectorAll('button').forEach(b=> b.disabled = v || b.textContent.startsWith('Cooldown'));
    renderAbilities(); // refresh disabled state
  }

  // Keyboard tips to avoid stuck listeners between screens:
  // (We reattach single-use listeners per choice render; actionLock gates clicks.)

  // Start
  startGame();
})();
</script>
</body>
</html>
